{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "\n# Example 7: Mann Eddy Lifetime Linear Regression\n\nThis example demonstrates the a simple configuration of ``DRDMannTurb`` to spectra fitting\nwhile using a linear approximation to the Mann eddy lifetime function (in log-log space)\nunder the Kaimal one-point spectra.\n\nFor reference, the full Mann eddy lifetime function is given by\n\n\\begin{align}\\tau^{\\mathrm{IEC}}(k)=\\frac{(k L)^{-\\frac{2}{3}}}{\\sqrt{{ }_2 F_1\\left(1 / 3,17 / 6 ; 4 / 3 ;-(k L)^{-2}\\right)}}\\end{align}\n\nwhere the hypergeometric function can only be evaluated on the CPU. The purpose of this example is\nto show how a GPU kernel of a linear approximation (in log-log space) of the Mann eddy lifetime can\nbe generated automatically to speed up tasks that require the GPU. As before, the Kaimal spectra is\nused for the one-point-spectra model.\n\nThe external API works the same as with other models, but the following may speed up some tasks\nthat rely exclusively on the Mann eddy lifetime function.\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Import packages\n\nFirst, we import the packages we need for this example.\n\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "collapsed": false
      },
      "outputs": [],
      "source": [
        "import torch\nimport torch.nn as nn\n\nfrom drdmannturb import EddyLifetimeType\nfrom drdmannturb.parameters import (\n    LossParameters,\n    NNParameters,\n    PhysicalParameters,\n    ProblemParameters,\n)\nfrom drdmannturb.spectra_fitting import CalibrationProblem, OnePointSpectraDataGenerator\n\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n\nif torch.cuda.is_available():\n    torch.set_default_tensor_type(\"torch.cuda.FloatTensor\")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Set up physical parameters and domain associated with the Kaimal spectrum.\nWe perform the spectra fitting over the $k_1$ space $[10^{{-1}}, 10^2]$\nwith 20 points.\n\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "collapsed": false
      },
      "outputs": [],
      "source": [
        "# Scales associated with Kaimal spectrum\nL = 0.59  # length scale\nGamma = 3.9  # time scale\nsigma = 3.2  # magnitude (\u03c3 = \u03b1\u03f5^{2/3})\n\nzref = 1  # reference height\n\ndomain = torch.logspace(-1, 2, 20)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## ``CalibrationProblem`` Construction\nThe following cell defines the ``CalibrationProblem`` using default values\nfor the ``NNParameters`` and ``LossParameters`` dataclasses. Importantly,\nthese data classes are not necessary, see their respective documentations for the default values.\nThe current set-up involves using the Mann model for the eddy lifetime function, meaning no\nneural network is used in learning the $\\tau$ function. Additionally, the physical parameters\nare taken from the reference values for the Kaimal spectra. Finally, in this scenario the regression\noccurs as an MSE fit to the spectra, which are generated from Mann turbulence (i.e. a synthetic data fit).\nThe ``EddyLifetimeType.MANN_APPROX`` argument determines the type of eddy lifetime function to use.\nHere, we will employ a linear regression to determine a surrogate eddy lifetime function. Using one\nevaluation of the Mann function on the provided spectra (here we are just taking it as if it's from a Mann model)\nwhich can be done from either synthetic or real-world data. In normal space, this is a function of the form $` \\exp(\\alpha \\boldsymbol{k} + \\beta)$\nwhere the $\\alpha, \\beta$ are coefficients determined by the linear regression in log-log space.\n\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "collapsed": false
      },
      "outputs": [],
      "source": [
        "pb = CalibrationProblem(\n    nn_params=NNParameters(\n        nlayers=2,\n        hidden_layer_sizes=[10, 10],\n        activations=[nn.ReLU(), nn.ReLU()],\n    ),\n    prob_params=ProblemParameters(\n        nepochs=10, eddy_lifetime=EddyLifetimeType.MANN_APPROX\n    ),\n    loss_params=LossParameters(),\n    phys_params=PhysicalParameters(L=L, Gamma=Gamma, sigma=sigma, domain=domain),\n    device=device,\n)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Data Generation\nIn the following cell, we construct our $k_1$ data points grid and\ngenerate the values. ``Data`` will be a tuple ``(<data points>, <data values>)``.\nIt is worth noting that the second element of each tuple in ``DataPoints`` is the corresponding\nreference height, which we have chosen to be uniformly `zref`.\n\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "collapsed": false
      },
      "outputs": [],
      "source": [
        "Data = OnePointSpectraDataGenerator(zref=zref, data_points=domain).Data"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Calibration\nNow, we fit our model. ``CalibrationProblem.calibrate`` takes the tuple ``Data``\nwhich we just constructed and performs a typical training loop.\n\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "collapsed": false
      },
      "outputs": [],
      "source": [
        "optimal_parameters = pb.calibrate(data=Data)\n\npb.print_calibrated_params()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The following plot shows the best fit to the synthetic Mann data. Notice that\nthe eddy lifetime function is linear in log-log space and is a close approximation\nto the Mann eddy lifetime function.\n\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "collapsed": false
      },
      "outputs": [],
      "source": [
        "pb.plot()"
      ]
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.9.13"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}